// Code generated by http://github.com/gojuno/minimock (v3.4.0). DO NOT EDIT.

package mock

//go:generate minimock -i effective-mobile-tz/pkg/app/song/service/song.Repository -o repository_mock.go -n RepositoryMock -p mock

import (
	"context"
	songRepoDTO "effective-mobile-tz/pkg/domain/dto/repository/song"
	"effective-mobile-tz/pkg/domain/model"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// RepositoryMock implements mm_song.Repository
type RepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcAdd          func(ctx context.Context, r songRepoDTO.AddRequest) (s1 model.SongID, err error)
	funcAddOrigin    string
	inspectFuncAdd   func(ctx context.Context, r songRepoDTO.AddRequest)
	afterAddCounter  uint64
	beforeAddCounter uint64
	AddMock          mRepositoryMockAdd

	funcGetAll          func(ctx context.Context, r songRepoDTO.GetAllRequest) (gp1 *songRepoDTO.GetAllResponse, err error)
	funcGetAllOrigin    string
	inspectFuncGetAll   func(ctx context.Context, r songRepoDTO.GetAllRequest)
	afterGetAllCounter  uint64
	beforeGetAllCounter uint64
	GetAllMock          mRepositoryMockGetAll

	funcGetText          func(ctx context.Context, r songRepoDTO.GetTextRequest) (gp1 *songRepoDTO.GetTextResponse, err error)
	funcGetTextOrigin    string
	inspectFuncGetText   func(ctx context.Context, r songRepoDTO.GetTextRequest)
	afterGetTextCounter  uint64
	beforeGetTextCounter uint64
	GetTextMock          mRepositoryMockGetText

	funcRemove          func(ctx context.Context, id model.SongID) (err error)
	funcRemoveOrigin    string
	inspectFuncRemove   func(ctx context.Context, id model.SongID)
	afterRemoveCounter  uint64
	beforeRemoveCounter uint64
	RemoveMock          mRepositoryMockRemove

	funcUpdate          func(ctx context.Context, r songRepoDTO.UpdateRequest) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, r songRepoDTO.UpdateRequest)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mRepositoryMockUpdate
}

// NewRepositoryMock returns a mock for mm_song.Repository
func NewRepositoryMock(t minimock.Tester) *RepositoryMock {
	m := &RepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AddMock = mRepositoryMockAdd{mock: m}
	m.AddMock.callArgs = []*RepositoryMockAddParams{}

	m.GetAllMock = mRepositoryMockGetAll{mock: m}
	m.GetAllMock.callArgs = []*RepositoryMockGetAllParams{}

	m.GetTextMock = mRepositoryMockGetText{mock: m}
	m.GetTextMock.callArgs = []*RepositoryMockGetTextParams{}

	m.RemoveMock = mRepositoryMockRemove{mock: m}
	m.RemoveMock.callArgs = []*RepositoryMockRemoveParams{}

	m.UpdateMock = mRepositoryMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*RepositoryMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mRepositoryMockAdd struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockAddExpectation
	expectations       []*RepositoryMockAddExpectation

	callArgs []*RepositoryMockAddParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockAddExpectation specifies expectation struct of the Repository.Add
type RepositoryMockAddExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockAddParams
	paramPtrs          *RepositoryMockAddParamPtrs
	expectationOrigins RepositoryMockAddExpectationOrigins
	results            *RepositoryMockAddResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockAddParams contains parameters of the Repository.Add
type RepositoryMockAddParams struct {
	ctx context.Context
	r   songRepoDTO.AddRequest
}

// RepositoryMockAddParamPtrs contains pointers to parameters of the Repository.Add
type RepositoryMockAddParamPtrs struct {
	ctx *context.Context
	r   *songRepoDTO.AddRequest
}

// RepositoryMockAddResults contains results of the Repository.Add
type RepositoryMockAddResults struct {
	s1  model.SongID
	err error
}

// RepositoryMockAddOrigins contains origins of expectations of the Repository.Add
type RepositoryMockAddExpectationOrigins struct {
	origin    string
	originCtx string
	originR   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmAdd *mRepositoryMockAdd) Optional() *mRepositoryMockAdd {
	mmAdd.optional = true
	return mmAdd
}

// Expect sets up expected params for Repository.Add
func (mmAdd *mRepositoryMockAdd) Expect(ctx context.Context, r songRepoDTO.AddRequest) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.paramPtrs != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by ExpectParams functions")
	}

	mmAdd.defaultExpectation.params = &RepositoryMockAddParams{ctx, r}
	mmAdd.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmAdd.expectations {
		if minimock.Equal(e.params, mmAdd.defaultExpectation.params) {
			mmAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAdd.defaultExpectation.params)
		}
	}

	return mmAdd
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Add
func (mmAdd *mRepositoryMockAdd) ExpectCtxParam1(ctx context.Context) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &RepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.ctx = &ctx
	mmAdd.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmAdd
}

// ExpectRParam2 sets up expected param r for Repository.Add
func (mmAdd *mRepositoryMockAdd) ExpectRParam2(r songRepoDTO.AddRequest) *mRepositoryMockAdd {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{}
	}

	if mmAdd.defaultExpectation.params != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Expect")
	}

	if mmAdd.defaultExpectation.paramPtrs == nil {
		mmAdd.defaultExpectation.paramPtrs = &RepositoryMockAddParamPtrs{}
	}
	mmAdd.defaultExpectation.paramPtrs.r = &r
	mmAdd.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmAdd
}

// Inspect accepts an inspector function that has same arguments as the Repository.Add
func (mmAdd *mRepositoryMockAdd) Inspect(f func(ctx context.Context, r songRepoDTO.AddRequest)) *mRepositoryMockAdd {
	if mmAdd.mock.inspectFuncAdd != nil {
		mmAdd.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Add")
	}

	mmAdd.mock.inspectFuncAdd = f

	return mmAdd
}

// Return sets up results that will be returned by Repository.Add
func (mmAdd *mRepositoryMockAdd) Return(s1 model.SongID, err error) *RepositoryMock {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	if mmAdd.defaultExpectation == nil {
		mmAdd.defaultExpectation = &RepositoryMockAddExpectation{mock: mmAdd.mock}
	}
	mmAdd.defaultExpectation.results = &RepositoryMockAddResults{s1, err}
	mmAdd.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// Set uses given function f to mock the Repository.Add method
func (mmAdd *mRepositoryMockAdd) Set(f func(ctx context.Context, r songRepoDTO.AddRequest) (s1 model.SongID, err error)) *RepositoryMock {
	if mmAdd.defaultExpectation != nil {
		mmAdd.mock.t.Fatalf("Default expectation is already set for the Repository.Add method")
	}

	if len(mmAdd.expectations) > 0 {
		mmAdd.mock.t.Fatalf("Some expectations are already set for the Repository.Add method")
	}

	mmAdd.mock.funcAdd = f
	mmAdd.mock.funcAddOrigin = minimock.CallerInfo(1)
	return mmAdd.mock
}

// When sets expectation for the Repository.Add which will trigger the result defined by the following
// Then helper
func (mmAdd *mRepositoryMockAdd) When(ctx context.Context, r songRepoDTO.AddRequest) *RepositoryMockAddExpectation {
	if mmAdd.mock.funcAdd != nil {
		mmAdd.mock.t.Fatalf("RepositoryMock.Add mock is already set by Set")
	}

	expectation := &RepositoryMockAddExpectation{
		mock:               mmAdd.mock,
		params:             &RepositoryMockAddParams{ctx, r},
		expectationOrigins: RepositoryMockAddExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmAdd.expectations = append(mmAdd.expectations, expectation)
	return expectation
}

// Then sets up Repository.Add return parameters for the expectation previously defined by the When method
func (e *RepositoryMockAddExpectation) Then(s1 model.SongID, err error) *RepositoryMock {
	e.results = &RepositoryMockAddResults{s1, err}
	return e.mock
}

// Times sets number of times Repository.Add should be invoked
func (mmAdd *mRepositoryMockAdd) Times(n uint64) *mRepositoryMockAdd {
	if n == 0 {
		mmAdd.mock.t.Fatalf("Times of RepositoryMock.Add mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmAdd.expectedInvocations, n)
	mmAdd.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmAdd
}

func (mmAdd *mRepositoryMockAdd) invocationsDone() bool {
	if len(mmAdd.expectations) == 0 && mmAdd.defaultExpectation == nil && mmAdd.mock.funcAdd == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmAdd.mock.afterAddCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmAdd.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Add implements mm_song.Repository
func (mmAdd *RepositoryMock) Add(ctx context.Context, r songRepoDTO.AddRequest) (s1 model.SongID, err error) {
	mm_atomic.AddUint64(&mmAdd.beforeAddCounter, 1)
	defer mm_atomic.AddUint64(&mmAdd.afterAddCounter, 1)

	mmAdd.t.Helper()

	if mmAdd.inspectFuncAdd != nil {
		mmAdd.inspectFuncAdd(ctx, r)
	}

	mm_params := RepositoryMockAddParams{ctx, r}

	// Record call args
	mmAdd.AddMock.mutex.Lock()
	mmAdd.AddMock.callArgs = append(mmAdd.AddMock.callArgs, &mm_params)
	mmAdd.AddMock.mutex.Unlock()

	for _, e := range mmAdd.AddMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmAdd.AddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAdd.AddMock.defaultExpectation.Counter, 1)
		mm_want := mmAdd.AddMock.defaultExpectation.params
		mm_want_ptrs := mmAdd.AddMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockAddParams{ctx, r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmAdd.AddMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAdd.t.Errorf("RepositoryMock.Add got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmAdd.AddMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAdd.AddMock.defaultExpectation.results
		if mm_results == nil {
			mmAdd.t.Fatal("No results are set for the RepositoryMock.Add")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmAdd.funcAdd != nil {
		return mmAdd.funcAdd(ctx, r)
	}
	mmAdd.t.Fatalf("Unexpected call to RepositoryMock.Add. %v %v", ctx, r)
	return
}

// AddAfterCounter returns a count of finished RepositoryMock.Add invocations
func (mmAdd *RepositoryMock) AddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.afterAddCounter)
}

// AddBeforeCounter returns a count of RepositoryMock.Add invocations
func (mmAdd *RepositoryMock) AddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAdd.beforeAddCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Add.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAdd *mRepositoryMockAdd) Calls() []*RepositoryMockAddParams {
	mmAdd.mutex.RLock()

	argCopy := make([]*RepositoryMockAddParams, len(mmAdd.callArgs))
	copy(argCopy, mmAdd.callArgs)

	mmAdd.mutex.RUnlock()

	return argCopy
}

// MinimockAddDone returns true if the count of the Add invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockAddDone() bool {
	if m.AddMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.AddMock.invocationsDone()
}

// MinimockAddInspect logs each unmet expectation
func (m *RepositoryMock) MinimockAddInspect() {
	for _, e := range m.AddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterAddCounter := mm_atomic.LoadUint64(&m.afterAddCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.AddMock.defaultExpectation != nil && afterAddCounter < 1 {
		if m.AddMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s", m.AddMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Add at\n%s with params: %#v", m.AddMock.defaultExpectation.expectationOrigins.origin, *m.AddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAdd != nil && afterAddCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Add at\n%s", m.funcAddOrigin)
	}

	if !m.AddMock.invocationsDone() && afterAddCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Add at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.AddMock.expectedInvocations), m.AddMock.expectedInvocationsOrigin, afterAddCounter)
	}
}

type mRepositoryMockGetAll struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetAllExpectation
	expectations       []*RepositoryMockGetAllExpectation

	callArgs []*RepositoryMockGetAllParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetAllExpectation specifies expectation struct of the Repository.GetAll
type RepositoryMockGetAllExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetAllParams
	paramPtrs          *RepositoryMockGetAllParamPtrs
	expectationOrigins RepositoryMockGetAllExpectationOrigins
	results            *RepositoryMockGetAllResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetAllParams contains parameters of the Repository.GetAll
type RepositoryMockGetAllParams struct {
	ctx context.Context
	r   songRepoDTO.GetAllRequest
}

// RepositoryMockGetAllParamPtrs contains pointers to parameters of the Repository.GetAll
type RepositoryMockGetAllParamPtrs struct {
	ctx *context.Context
	r   *songRepoDTO.GetAllRequest
}

// RepositoryMockGetAllResults contains results of the Repository.GetAll
type RepositoryMockGetAllResults struct {
	gp1 *songRepoDTO.GetAllResponse
	err error
}

// RepositoryMockGetAllOrigins contains origins of expectations of the Repository.GetAll
type RepositoryMockGetAllExpectationOrigins struct {
	origin    string
	originCtx string
	originR   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAll *mRepositoryMockGetAll) Optional() *mRepositoryMockGetAll {
	mmGetAll.optional = true
	return mmGetAll
}

// Expect sets up expected params for Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Expect(ctx context.Context, r songRepoDTO.GetAllRequest) *mRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.paramPtrs != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by ExpectParams functions")
	}

	mmGetAll.defaultExpectation.params = &RepositoryMockGetAllParams{ctx, r}
	mmGetAll.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetAll.expectations {
		if minimock.Equal(e.params, mmGetAll.defaultExpectation.params) {
			mmGetAll.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAll.defaultExpectation.params)
		}
	}

	return mmGetAll
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &RepositoryMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetAll.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetAll
}

// ExpectRParam2 sets up expected param r for Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) ExpectRParam2(r songRepoDTO.GetAllRequest) *mRepositoryMockGetAll {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{}
	}

	if mmGetAll.defaultExpectation.params != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Expect")
	}

	if mmGetAll.defaultExpectation.paramPtrs == nil {
		mmGetAll.defaultExpectation.paramPtrs = &RepositoryMockGetAllParamPtrs{}
	}
	mmGetAll.defaultExpectation.paramPtrs.r = &r
	mmGetAll.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmGetAll
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Inspect(f func(ctx context.Context, r songRepoDTO.GetAllRequest)) *mRepositoryMockGetAll {
	if mmGetAll.mock.inspectFuncGetAll != nil {
		mmGetAll.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetAll")
	}

	mmGetAll.mock.inspectFuncGetAll = f

	return mmGetAll
}

// Return sets up results that will be returned by Repository.GetAll
func (mmGetAll *mRepositoryMockGetAll) Return(gp1 *songRepoDTO.GetAllResponse, err error) *RepositoryMock {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	if mmGetAll.defaultExpectation == nil {
		mmGetAll.defaultExpectation = &RepositoryMockGetAllExpectation{mock: mmGetAll.mock}
	}
	mmGetAll.defaultExpectation.results = &RepositoryMockGetAllResults{gp1, err}
	mmGetAll.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// Set uses given function f to mock the Repository.GetAll method
func (mmGetAll *mRepositoryMockGetAll) Set(f func(ctx context.Context, r songRepoDTO.GetAllRequest) (gp1 *songRepoDTO.GetAllResponse, err error)) *RepositoryMock {
	if mmGetAll.defaultExpectation != nil {
		mmGetAll.mock.t.Fatalf("Default expectation is already set for the Repository.GetAll method")
	}

	if len(mmGetAll.expectations) > 0 {
		mmGetAll.mock.t.Fatalf("Some expectations are already set for the Repository.GetAll method")
	}

	mmGetAll.mock.funcGetAll = f
	mmGetAll.mock.funcGetAllOrigin = minimock.CallerInfo(1)
	return mmGetAll.mock
}

// When sets expectation for the Repository.GetAll which will trigger the result defined by the following
// Then helper
func (mmGetAll *mRepositoryMockGetAll) When(ctx context.Context, r songRepoDTO.GetAllRequest) *RepositoryMockGetAllExpectation {
	if mmGetAll.mock.funcGetAll != nil {
		mmGetAll.mock.t.Fatalf("RepositoryMock.GetAll mock is already set by Set")
	}

	expectation := &RepositoryMockGetAllExpectation{
		mock:               mmGetAll.mock,
		params:             &RepositoryMockGetAllParams{ctx, r},
		expectationOrigins: RepositoryMockGetAllExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetAll.expectations = append(mmGetAll.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetAll return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetAllExpectation) Then(gp1 *songRepoDTO.GetAllResponse, err error) *RepositoryMock {
	e.results = &RepositoryMockGetAllResults{gp1, err}
	return e.mock
}

// Times sets number of times Repository.GetAll should be invoked
func (mmGetAll *mRepositoryMockGetAll) Times(n uint64) *mRepositoryMockGetAll {
	if n == 0 {
		mmGetAll.mock.t.Fatalf("Times of RepositoryMock.GetAll mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAll.expectedInvocations, n)
	mmGetAll.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetAll
}

func (mmGetAll *mRepositoryMockGetAll) invocationsDone() bool {
	if len(mmGetAll.expectations) == 0 && mmGetAll.defaultExpectation == nil && mmGetAll.mock.funcGetAll == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAll.mock.afterGetAllCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAll.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAll implements mm_song.Repository
func (mmGetAll *RepositoryMock) GetAll(ctx context.Context, r songRepoDTO.GetAllRequest) (gp1 *songRepoDTO.GetAllResponse, err error) {
	mm_atomic.AddUint64(&mmGetAll.beforeGetAllCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAll.afterGetAllCounter, 1)

	mmGetAll.t.Helper()

	if mmGetAll.inspectFuncGetAll != nil {
		mmGetAll.inspectFuncGetAll(ctx, r)
	}

	mm_params := RepositoryMockGetAllParams{ctx, r}

	// Record call args
	mmGetAll.GetAllMock.mutex.Lock()
	mmGetAll.GetAllMock.callArgs = append(mmGetAll.GetAllMock.callArgs, &mm_params)
	mmGetAll.GetAllMock.mutex.Unlock()

	for _, e := range mmGetAll.GetAllMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetAll.GetAllMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAll.GetAllMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAll.GetAllMock.defaultExpectation.params
		mm_want_ptrs := mmGetAll.GetAllMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetAllParams{ctx, r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAll.t.Errorf("RepositoryMock.GetAll got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmGetAll.t.Errorf("RepositoryMock.GetAll got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAll.t.Errorf("RepositoryMock.GetAll got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetAll.GetAllMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAll.GetAllMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAll.t.Fatal("No results are set for the RepositoryMock.GetAll")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetAll.funcGetAll != nil {
		return mmGetAll.funcGetAll(ctx, r)
	}
	mmGetAll.t.Fatalf("Unexpected call to RepositoryMock.GetAll. %v %v", ctx, r)
	return
}

// GetAllAfterCounter returns a count of finished RepositoryMock.GetAll invocations
func (mmGetAll *RepositoryMock) GetAllAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.afterGetAllCounter)
}

// GetAllBeforeCounter returns a count of RepositoryMock.GetAll invocations
func (mmGetAll *RepositoryMock) GetAllBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAll.beforeGetAllCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetAll.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAll *mRepositoryMockGetAll) Calls() []*RepositoryMockGetAllParams {
	mmGetAll.mutex.RLock()

	argCopy := make([]*RepositoryMockGetAllParams, len(mmGetAll.callArgs))
	copy(argCopy, mmGetAll.callArgs)

	mmGetAll.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllDone returns true if the count of the GetAll invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetAllDone() bool {
	if m.GetAllMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllMock.invocationsDone()
}

// MinimockGetAllInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetAllInspect() {
	for _, e := range m.GetAllMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetAllCounter := mm_atomic.LoadUint64(&m.afterGetAllCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllMock.defaultExpectation != nil && afterGetAllCounter < 1 {
		if m.GetAllMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s", m.GetAllMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s with params: %#v", m.GetAllMock.defaultExpectation.expectationOrigins.origin, *m.GetAllMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAll != nil && afterGetAllCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetAll at\n%s", m.funcGetAllOrigin)
	}

	if !m.GetAllMock.invocationsDone() && afterGetAllCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetAll at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllMock.expectedInvocations), m.GetAllMock.expectedInvocationsOrigin, afterGetAllCounter)
	}
}

type mRepositoryMockGetText struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockGetTextExpectation
	expectations       []*RepositoryMockGetTextExpectation

	callArgs []*RepositoryMockGetTextParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockGetTextExpectation specifies expectation struct of the Repository.GetText
type RepositoryMockGetTextExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockGetTextParams
	paramPtrs          *RepositoryMockGetTextParamPtrs
	expectationOrigins RepositoryMockGetTextExpectationOrigins
	results            *RepositoryMockGetTextResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockGetTextParams contains parameters of the Repository.GetText
type RepositoryMockGetTextParams struct {
	ctx context.Context
	r   songRepoDTO.GetTextRequest
}

// RepositoryMockGetTextParamPtrs contains pointers to parameters of the Repository.GetText
type RepositoryMockGetTextParamPtrs struct {
	ctx *context.Context
	r   *songRepoDTO.GetTextRequest
}

// RepositoryMockGetTextResults contains results of the Repository.GetText
type RepositoryMockGetTextResults struct {
	gp1 *songRepoDTO.GetTextResponse
	err error
}

// RepositoryMockGetTextOrigins contains origins of expectations of the Repository.GetText
type RepositoryMockGetTextExpectationOrigins struct {
	origin    string
	originCtx string
	originR   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetText *mRepositoryMockGetText) Optional() *mRepositoryMockGetText {
	mmGetText.optional = true
	return mmGetText
}

// Expect sets up expected params for Repository.GetText
func (mmGetText *mRepositoryMockGetText) Expect(ctx context.Context, r songRepoDTO.GetTextRequest) *mRepositoryMockGetText {
	if mmGetText.mock.funcGetText != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Set")
	}

	if mmGetText.defaultExpectation == nil {
		mmGetText.defaultExpectation = &RepositoryMockGetTextExpectation{}
	}

	if mmGetText.defaultExpectation.paramPtrs != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by ExpectParams functions")
	}

	mmGetText.defaultExpectation.params = &RepositoryMockGetTextParams{ctx, r}
	mmGetText.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetText.expectations {
		if minimock.Equal(e.params, mmGetText.defaultExpectation.params) {
			mmGetText.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetText.defaultExpectation.params)
		}
	}

	return mmGetText
}

// ExpectCtxParam1 sets up expected param ctx for Repository.GetText
func (mmGetText *mRepositoryMockGetText) ExpectCtxParam1(ctx context.Context) *mRepositoryMockGetText {
	if mmGetText.mock.funcGetText != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Set")
	}

	if mmGetText.defaultExpectation == nil {
		mmGetText.defaultExpectation = &RepositoryMockGetTextExpectation{}
	}

	if mmGetText.defaultExpectation.params != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Expect")
	}

	if mmGetText.defaultExpectation.paramPtrs == nil {
		mmGetText.defaultExpectation.paramPtrs = &RepositoryMockGetTextParamPtrs{}
	}
	mmGetText.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetText.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetText
}

// ExpectRParam2 sets up expected param r for Repository.GetText
func (mmGetText *mRepositoryMockGetText) ExpectRParam2(r songRepoDTO.GetTextRequest) *mRepositoryMockGetText {
	if mmGetText.mock.funcGetText != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Set")
	}

	if mmGetText.defaultExpectation == nil {
		mmGetText.defaultExpectation = &RepositoryMockGetTextExpectation{}
	}

	if mmGetText.defaultExpectation.params != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Expect")
	}

	if mmGetText.defaultExpectation.paramPtrs == nil {
		mmGetText.defaultExpectation.paramPtrs = &RepositoryMockGetTextParamPtrs{}
	}
	mmGetText.defaultExpectation.paramPtrs.r = &r
	mmGetText.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmGetText
}

// Inspect accepts an inspector function that has same arguments as the Repository.GetText
func (mmGetText *mRepositoryMockGetText) Inspect(f func(ctx context.Context, r songRepoDTO.GetTextRequest)) *mRepositoryMockGetText {
	if mmGetText.mock.inspectFuncGetText != nil {
		mmGetText.mock.t.Fatalf("Inspect function is already set for RepositoryMock.GetText")
	}

	mmGetText.mock.inspectFuncGetText = f

	return mmGetText
}

// Return sets up results that will be returned by Repository.GetText
func (mmGetText *mRepositoryMockGetText) Return(gp1 *songRepoDTO.GetTextResponse, err error) *RepositoryMock {
	if mmGetText.mock.funcGetText != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Set")
	}

	if mmGetText.defaultExpectation == nil {
		mmGetText.defaultExpectation = &RepositoryMockGetTextExpectation{mock: mmGetText.mock}
	}
	mmGetText.defaultExpectation.results = &RepositoryMockGetTextResults{gp1, err}
	mmGetText.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetText.mock
}

// Set uses given function f to mock the Repository.GetText method
func (mmGetText *mRepositoryMockGetText) Set(f func(ctx context.Context, r songRepoDTO.GetTextRequest) (gp1 *songRepoDTO.GetTextResponse, err error)) *RepositoryMock {
	if mmGetText.defaultExpectation != nil {
		mmGetText.mock.t.Fatalf("Default expectation is already set for the Repository.GetText method")
	}

	if len(mmGetText.expectations) > 0 {
		mmGetText.mock.t.Fatalf("Some expectations are already set for the Repository.GetText method")
	}

	mmGetText.mock.funcGetText = f
	mmGetText.mock.funcGetTextOrigin = minimock.CallerInfo(1)
	return mmGetText.mock
}

// When sets expectation for the Repository.GetText which will trigger the result defined by the following
// Then helper
func (mmGetText *mRepositoryMockGetText) When(ctx context.Context, r songRepoDTO.GetTextRequest) *RepositoryMockGetTextExpectation {
	if mmGetText.mock.funcGetText != nil {
		mmGetText.mock.t.Fatalf("RepositoryMock.GetText mock is already set by Set")
	}

	expectation := &RepositoryMockGetTextExpectation{
		mock:               mmGetText.mock,
		params:             &RepositoryMockGetTextParams{ctx, r},
		expectationOrigins: RepositoryMockGetTextExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetText.expectations = append(mmGetText.expectations, expectation)
	return expectation
}

// Then sets up Repository.GetText return parameters for the expectation previously defined by the When method
func (e *RepositoryMockGetTextExpectation) Then(gp1 *songRepoDTO.GetTextResponse, err error) *RepositoryMock {
	e.results = &RepositoryMockGetTextResults{gp1, err}
	return e.mock
}

// Times sets number of times Repository.GetText should be invoked
func (mmGetText *mRepositoryMockGetText) Times(n uint64) *mRepositoryMockGetText {
	if n == 0 {
		mmGetText.mock.t.Fatalf("Times of RepositoryMock.GetText mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetText.expectedInvocations, n)
	mmGetText.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetText
}

func (mmGetText *mRepositoryMockGetText) invocationsDone() bool {
	if len(mmGetText.expectations) == 0 && mmGetText.defaultExpectation == nil && mmGetText.mock.funcGetText == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetText.mock.afterGetTextCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetText.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetText implements mm_song.Repository
func (mmGetText *RepositoryMock) GetText(ctx context.Context, r songRepoDTO.GetTextRequest) (gp1 *songRepoDTO.GetTextResponse, err error) {
	mm_atomic.AddUint64(&mmGetText.beforeGetTextCounter, 1)
	defer mm_atomic.AddUint64(&mmGetText.afterGetTextCounter, 1)

	mmGetText.t.Helper()

	if mmGetText.inspectFuncGetText != nil {
		mmGetText.inspectFuncGetText(ctx, r)
	}

	mm_params := RepositoryMockGetTextParams{ctx, r}

	// Record call args
	mmGetText.GetTextMock.mutex.Lock()
	mmGetText.GetTextMock.callArgs = append(mmGetText.GetTextMock.callArgs, &mm_params)
	mmGetText.GetTextMock.mutex.Unlock()

	for _, e := range mmGetText.GetTextMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGetText.GetTextMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetText.GetTextMock.defaultExpectation.Counter, 1)
		mm_want := mmGetText.GetTextMock.defaultExpectation.params
		mm_want_ptrs := mmGetText.GetTextMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockGetTextParams{ctx, r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetText.t.Errorf("RepositoryMock.GetText got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetText.GetTextMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmGetText.t.Errorf("RepositoryMock.GetText got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetText.GetTextMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetText.t.Errorf("RepositoryMock.GetText got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetText.GetTextMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetText.GetTextMock.defaultExpectation.results
		if mm_results == nil {
			mmGetText.t.Fatal("No results are set for the RepositoryMock.GetText")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGetText.funcGetText != nil {
		return mmGetText.funcGetText(ctx, r)
	}
	mmGetText.t.Fatalf("Unexpected call to RepositoryMock.GetText. %v %v", ctx, r)
	return
}

// GetTextAfterCounter returns a count of finished RepositoryMock.GetText invocations
func (mmGetText *RepositoryMock) GetTextAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetText.afterGetTextCounter)
}

// GetTextBeforeCounter returns a count of RepositoryMock.GetText invocations
func (mmGetText *RepositoryMock) GetTextBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetText.beforeGetTextCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.GetText.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetText *mRepositoryMockGetText) Calls() []*RepositoryMockGetTextParams {
	mmGetText.mutex.RLock()

	argCopy := make([]*RepositoryMockGetTextParams, len(mmGetText.callArgs))
	copy(argCopy, mmGetText.callArgs)

	mmGetText.mutex.RUnlock()

	return argCopy
}

// MinimockGetTextDone returns true if the count of the GetText invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockGetTextDone() bool {
	if m.GetTextMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetTextMock.invocationsDone()
}

// MinimockGetTextInspect logs each unmet expectation
func (m *RepositoryMock) MinimockGetTextInspect() {
	for _, e := range m.GetTextMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.GetText at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetTextCounter := mm_atomic.LoadUint64(&m.afterGetTextCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetTextMock.defaultExpectation != nil && afterGetTextCounter < 1 {
		if m.GetTextMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.GetText at\n%s", m.GetTextMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.GetText at\n%s with params: %#v", m.GetTextMock.defaultExpectation.expectationOrigins.origin, *m.GetTextMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetText != nil && afterGetTextCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.GetText at\n%s", m.funcGetTextOrigin)
	}

	if !m.GetTextMock.invocationsDone() && afterGetTextCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.GetText at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetTextMock.expectedInvocations), m.GetTextMock.expectedInvocationsOrigin, afterGetTextCounter)
	}
}

type mRepositoryMockRemove struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockRemoveExpectation
	expectations       []*RepositoryMockRemoveExpectation

	callArgs []*RepositoryMockRemoveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockRemoveExpectation specifies expectation struct of the Repository.Remove
type RepositoryMockRemoveExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockRemoveParams
	paramPtrs          *RepositoryMockRemoveParamPtrs
	expectationOrigins RepositoryMockRemoveExpectationOrigins
	results            *RepositoryMockRemoveResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockRemoveParams contains parameters of the Repository.Remove
type RepositoryMockRemoveParams struct {
	ctx context.Context
	id  model.SongID
}

// RepositoryMockRemoveParamPtrs contains pointers to parameters of the Repository.Remove
type RepositoryMockRemoveParamPtrs struct {
	ctx *context.Context
	id  *model.SongID
}

// RepositoryMockRemoveResults contains results of the Repository.Remove
type RepositoryMockRemoveResults struct {
	err error
}

// RepositoryMockRemoveOrigins contains origins of expectations of the Repository.Remove
type RepositoryMockRemoveExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemove *mRepositoryMockRemove) Optional() *mRepositoryMockRemove {
	mmRemove.optional = true
	return mmRemove
}

// Expect sets up expected params for Repository.Remove
func (mmRemove *mRepositoryMockRemove) Expect(ctx context.Context, id model.SongID) *mRepositoryMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &RepositoryMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.paramPtrs != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by ExpectParams functions")
	}

	mmRemove.defaultExpectation.params = &RepositoryMockRemoveParams{ctx, id}
	mmRemove.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemove.expectations {
		if minimock.Equal(e.params, mmRemove.defaultExpectation.params) {
			mmRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemove.defaultExpectation.params)
		}
	}

	return mmRemove
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Remove
func (mmRemove *mRepositoryMockRemove) ExpectCtxParam1(ctx context.Context) *mRepositoryMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &RepositoryMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &RepositoryMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemove.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemove
}

// ExpectIdParam2 sets up expected param id for Repository.Remove
func (mmRemove *mRepositoryMockRemove) ExpectIdParam2(id model.SongID) *mRepositoryMockRemove {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &RepositoryMockRemoveExpectation{}
	}

	if mmRemove.defaultExpectation.params != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Expect")
	}

	if mmRemove.defaultExpectation.paramPtrs == nil {
		mmRemove.defaultExpectation.paramPtrs = &RepositoryMockRemoveParamPtrs{}
	}
	mmRemove.defaultExpectation.paramPtrs.id = &id
	mmRemove.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmRemove
}

// Inspect accepts an inspector function that has same arguments as the Repository.Remove
func (mmRemove *mRepositoryMockRemove) Inspect(f func(ctx context.Context, id model.SongID)) *mRepositoryMockRemove {
	if mmRemove.mock.inspectFuncRemove != nil {
		mmRemove.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Remove")
	}

	mmRemove.mock.inspectFuncRemove = f

	return mmRemove
}

// Return sets up results that will be returned by Repository.Remove
func (mmRemove *mRepositoryMockRemove) Return(err error) *RepositoryMock {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Set")
	}

	if mmRemove.defaultExpectation == nil {
		mmRemove.defaultExpectation = &RepositoryMockRemoveExpectation{mock: mmRemove.mock}
	}
	mmRemove.defaultExpectation.results = &RepositoryMockRemoveResults{err}
	mmRemove.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// Set uses given function f to mock the Repository.Remove method
func (mmRemove *mRepositoryMockRemove) Set(f func(ctx context.Context, id model.SongID) (err error)) *RepositoryMock {
	if mmRemove.defaultExpectation != nil {
		mmRemove.mock.t.Fatalf("Default expectation is already set for the Repository.Remove method")
	}

	if len(mmRemove.expectations) > 0 {
		mmRemove.mock.t.Fatalf("Some expectations are already set for the Repository.Remove method")
	}

	mmRemove.mock.funcRemove = f
	mmRemove.mock.funcRemoveOrigin = minimock.CallerInfo(1)
	return mmRemove.mock
}

// When sets expectation for the Repository.Remove which will trigger the result defined by the following
// Then helper
func (mmRemove *mRepositoryMockRemove) When(ctx context.Context, id model.SongID) *RepositoryMockRemoveExpectation {
	if mmRemove.mock.funcRemove != nil {
		mmRemove.mock.t.Fatalf("RepositoryMock.Remove mock is already set by Set")
	}

	expectation := &RepositoryMockRemoveExpectation{
		mock:               mmRemove.mock,
		params:             &RepositoryMockRemoveParams{ctx, id},
		expectationOrigins: RepositoryMockRemoveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemove.expectations = append(mmRemove.expectations, expectation)
	return expectation
}

// Then sets up Repository.Remove return parameters for the expectation previously defined by the When method
func (e *RepositoryMockRemoveExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockRemoveResults{err}
	return e.mock
}

// Times sets number of times Repository.Remove should be invoked
func (mmRemove *mRepositoryMockRemove) Times(n uint64) *mRepositoryMockRemove {
	if n == 0 {
		mmRemove.mock.t.Fatalf("Times of RepositoryMock.Remove mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemove.expectedInvocations, n)
	mmRemove.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemove
}

func (mmRemove *mRepositoryMockRemove) invocationsDone() bool {
	if len(mmRemove.expectations) == 0 && mmRemove.defaultExpectation == nil && mmRemove.mock.funcRemove == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemove.mock.afterRemoveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemove.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Remove implements mm_song.Repository
func (mmRemove *RepositoryMock) Remove(ctx context.Context, id model.SongID) (err error) {
	mm_atomic.AddUint64(&mmRemove.beforeRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmRemove.afterRemoveCounter, 1)

	mmRemove.t.Helper()

	if mmRemove.inspectFuncRemove != nil {
		mmRemove.inspectFuncRemove(ctx, id)
	}

	mm_params := RepositoryMockRemoveParams{ctx, id}

	// Record call args
	mmRemove.RemoveMock.mutex.Lock()
	mmRemove.RemoveMock.callArgs = append(mmRemove.RemoveMock.callArgs, &mm_params)
	mmRemove.RemoveMock.mutex.Unlock()

	for _, e := range mmRemove.RemoveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemove.RemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemove.RemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmRemove.RemoveMock.defaultExpectation.params
		mm_want_ptrs := mmRemove.RemoveMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockRemoveParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemove.t.Errorf("RepositoryMock.Remove got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmRemove.t.Errorf("RepositoryMock.Remove got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemove.RemoveMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemove.t.Errorf("RepositoryMock.Remove got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemove.RemoveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemove.RemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmRemove.t.Fatal("No results are set for the RepositoryMock.Remove")
		}
		return (*mm_results).err
	}
	if mmRemove.funcRemove != nil {
		return mmRemove.funcRemove(ctx, id)
	}
	mmRemove.t.Fatalf("Unexpected call to RepositoryMock.Remove. %v %v", ctx, id)
	return
}

// RemoveAfterCounter returns a count of finished RepositoryMock.Remove invocations
func (mmRemove *RepositoryMock) RemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.afterRemoveCounter)
}

// RemoveBeforeCounter returns a count of RepositoryMock.Remove invocations
func (mmRemove *RepositoryMock) RemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemove.beforeRemoveCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Remove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemove *mRepositoryMockRemove) Calls() []*RepositoryMockRemoveParams {
	mmRemove.mutex.RLock()

	argCopy := make([]*RepositoryMockRemoveParams, len(mmRemove.callArgs))
	copy(argCopy, mmRemove.callArgs)

	mmRemove.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveDone returns true if the count of the Remove invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockRemoveDone() bool {
	if m.RemoveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveMock.invocationsDone()
}

// MinimockRemoveInspect logs each unmet expectation
func (m *RepositoryMock) MinimockRemoveInspect() {
	for _, e := range m.RemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Remove at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveCounter := mm_atomic.LoadUint64(&m.afterRemoveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveMock.defaultExpectation != nil && afterRemoveCounter < 1 {
		if m.RemoveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Remove at\n%s", m.RemoveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Remove at\n%s with params: %#v", m.RemoveMock.defaultExpectation.expectationOrigins.origin, *m.RemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemove != nil && afterRemoveCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Remove at\n%s", m.funcRemoveOrigin)
	}

	if !m.RemoveMock.invocationsDone() && afterRemoveCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Remove at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveMock.expectedInvocations), m.RemoveMock.expectedInvocationsOrigin, afterRemoveCounter)
	}
}

type mRepositoryMockUpdate struct {
	optional           bool
	mock               *RepositoryMock
	defaultExpectation *RepositoryMockUpdateExpectation
	expectations       []*RepositoryMockUpdateExpectation

	callArgs []*RepositoryMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// RepositoryMockUpdateExpectation specifies expectation struct of the Repository.Update
type RepositoryMockUpdateExpectation struct {
	mock               *RepositoryMock
	params             *RepositoryMockUpdateParams
	paramPtrs          *RepositoryMockUpdateParamPtrs
	expectationOrigins RepositoryMockUpdateExpectationOrigins
	results            *RepositoryMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// RepositoryMockUpdateParams contains parameters of the Repository.Update
type RepositoryMockUpdateParams struct {
	ctx context.Context
	r   songRepoDTO.UpdateRequest
}

// RepositoryMockUpdateParamPtrs contains pointers to parameters of the Repository.Update
type RepositoryMockUpdateParamPtrs struct {
	ctx *context.Context
	r   *songRepoDTO.UpdateRequest
}

// RepositoryMockUpdateResults contains results of the Repository.Update
type RepositoryMockUpdateResults struct {
	err error
}

// RepositoryMockUpdateOrigins contains origins of expectations of the Repository.Update
type RepositoryMockUpdateExpectationOrigins struct {
	origin    string
	originCtx string
	originR   string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mRepositoryMockUpdate) Optional() *mRepositoryMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Expect(ctx context.Context, r songRepoDTO.UpdateRequest) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &RepositoryMockUpdateParams{ctx, r}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) ExpectCtxParam1(ctx context.Context) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &RepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectRParam2 sets up expected param r for Repository.Update
func (mmUpdate *mRepositoryMockUpdate) ExpectRParam2(r songRepoDTO.UpdateRequest) *mRepositoryMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &RepositoryMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.r = &r
	mmUpdate.defaultExpectation.expectationOrigins.originR = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Inspect(f func(ctx context.Context, r songRepoDTO.UpdateRequest)) *mRepositoryMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for RepositoryMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by Repository.Update
func (mmUpdate *mRepositoryMockUpdate) Return(err error) *RepositoryMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &RepositoryMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &RepositoryMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the Repository.Update method
func (mmUpdate *mRepositoryMockUpdate) Set(f func(ctx context.Context, r songRepoDTO.UpdateRequest) (err error)) *RepositoryMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the Repository.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the Repository.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the Repository.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mRepositoryMockUpdate) When(ctx context.Context, r songRepoDTO.UpdateRequest) *RepositoryMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("RepositoryMock.Update mock is already set by Set")
	}

	expectation := &RepositoryMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &RepositoryMockUpdateParams{ctx, r},
		expectationOrigins: RepositoryMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up Repository.Update return parameters for the expectation previously defined by the When method
func (e *RepositoryMockUpdateExpectation) Then(err error) *RepositoryMock {
	e.results = &RepositoryMockUpdateResults{err}
	return e.mock
}

// Times sets number of times Repository.Update should be invoked
func (mmUpdate *mRepositoryMockUpdate) Times(n uint64) *mRepositoryMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of RepositoryMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mRepositoryMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_song.Repository
func (mmUpdate *RepositoryMock) Update(ctx context.Context, r songRepoDTO.UpdateRequest) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, r)
	}

	mm_params := RepositoryMockUpdateParams{ctx, r}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := RepositoryMockUpdateParams{ctx, r}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.r != nil && !minimock.Equal(*mm_want_ptrs.r, mm_got.r) {
				mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameter r, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originR, *mm_want_ptrs.r, mm_got.r, minimock.Diff(*mm_want_ptrs.r, mm_got.r))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("RepositoryMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the RepositoryMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, r)
	}
	mmUpdate.t.Fatalf("Unexpected call to RepositoryMock.Update. %v %v", ctx, r)
	return
}

// UpdateAfterCounter returns a count of finished RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of RepositoryMock.Update invocations
func (mmUpdate *RepositoryMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to RepositoryMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mRepositoryMockUpdate) Calls() []*RepositoryMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*RepositoryMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *RepositoryMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *RepositoryMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to RepositoryMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to RepositoryMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to RepositoryMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *RepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockAddInspect()

			m.MinimockGetAllInspect()

			m.MinimockGetTextInspect()

			m.MinimockRemoveInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *RepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *RepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAddDone() &&
		m.MinimockGetAllDone() &&
		m.MinimockGetTextDone() &&
		m.MinimockRemoveDone() &&
		m.MinimockUpdateDone()
}
